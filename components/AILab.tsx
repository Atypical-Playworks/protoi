
import React, { useState, useRef, useEffect } from 'react';
import ReactDOM from 'react-dom';
import ReactMarkdown from 'react-markdown';
import { Project } from '../types';
import { geminiService, GeminiService } from '../services/geminiService';
import {
  Sparkles, Zap, Loader2, Terminal, Copy, Check,
  Volume2, StopCircle, Lightbulb,
  Target, FileText, Rocket, Download, Trash2,
  CheckCircle2, ArrowRight, MessageSquare, Send,
  LayoutTemplate, Layers, Code2, Database, Plus, History, X,
  Maximize2, Minimize2, Eye, RefreshCw
} from 'lucide-react';
import { useLanguage } from '../contexts/LanguageContext';

// Model Selection
const FAST_MODEL = 'gemini-3-flash-preview';
const REASONING_MODEL = 'gemini-3-pro-preview';

interface AILabProps {
  projects: Project[];
  extraContext?: { name: string, content: string }[];
}

type PlatformType = 'v0' | 'lovable' | 'google' | null;

interface Pipeline {
  platform: PlatformType;
  idea: string | null;
  validation: string | null;
  prd: string | null;
  masterPrompt: string | null;
  uiPreview: string | null;  // HTML preview generated by Flash UI style
}

interface ChatMessage {
  role: 'user' | 'assistant';
  content: string;
}

interface Thread {
  id: string;
  title: string;
  messages: ChatMessage[];
  createdAt: number;
}

interface BuildSession {
  id: string;
  name: string;
  pipeline: Pipeline;
  builderStep: number;
  createdAt: number;
  updatedAt: number;
}

// Helper to decode Base64
function decode(base64: string) {
  const binaryString = atob(base64);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}

// Helper to decode PCM/Audio Data
async function decodeAudioData(
  data: Uint8Array,
  ctx: AudioContext,
  sampleRate: number,
  numChannels: number,
): Promise<AudioBuffer> {
  const dataInt16 = new Int16Array(data.buffer);
  const frameCount = dataInt16.length / numChannels;
  const buffer = ctx.createBuffer(numChannels, frameCount, sampleRate);

  for (let channel = 0; channel < numChannels; channel++) {
    const channelData = buffer.getChannelData(channel);
    for (let i = 0; i < frameCount; i++) {
      channelData[i] = dataInt16[i * numChannels + channel] / 32768.0;
    }
  }
  return buffer;
}

export const AILab: React.FC<AILabProps> = ({ projects, extraContext = [] }) => {
  const { language, t } = useLanguage();

  // Mode: 'explorer' (Chat) or 'builder' (Pipeline)
  const [mode, setMode] = useState<'explorer' | 'builder'>('explorer');

  // --- THREADS STATE ---
  const [threads, setThreads] = useState<Thread[]>([]);
  const [activeThreadId, setActiveThreadId] = useState<string | null>(null);
  const [newQueryInput, setNewQueryInput] = useState(''); // Input in aside (new thread)
  const [followUpInput, setFollowUpInput] = useState(''); // Input in terminal (continue thread)
  const [isChatLoading, setIsChatLoading] = useState(false);
  const chatEndRef = useRef<HTMLDivElement>(null);

  // --- BUILD SESSIONS STATE ---
  const [buildSessions, setBuildSessions] = useState<BuildSession[]>([]);
  const [showBuildHistory, setShowBuildHistory] = useState(false);
  const [saveSessionName, setSaveSessionName] = useState('');

  // --- TERMINAL MODAL STATE ---
  const [isTerminalMaximized, setIsTerminalMaximized] = useState(false);

  // Get active thread
  const activeThread = threads.find(t => t.id === activeThreadId) || null;
  const chatMessages = activeThread?.messages || [];

  // --- BUILDER STATE ---
  const [builderStep, setBuilderStep] = useState(0); // 0=Platform, 1=Idea, 2=Validation, 3=PRD, 4=Prompt
  const [pipeline, setPipeline] = useState<Pipeline>({
    platform: null,
    idea: null,
    validation: null,
    prd: null,
    masterPrompt: null,
    uiPreview: null
  });
  const [ideaInput, setIdeaInput] = useState('');
  const [isGenerating, setIsGenerating] = useState(false);
  const [isGeneratingPreview, setIsGeneratingPreview] = useState(false);
  const [isPreviewFullscreen, setIsPreviewFullscreen] = useState(false);
  const [streamingContent, setStreamingContent] = useState<string>(''); // For streaming responses
  const [previewTypewriterText, setPreviewTypewriterText] = useState<string>(''); // For typewriter effect in preview

  // --- AUDIO STATE ---
  const [isGeneratingAudio, setIsGeneratingAudio] = useState(false);
  const [isPlaying, setIsPlaying] = useState(false);
  const audioContextRef = useRef<AudioContext | null>(null);
  const audioSourceRef = useRef<AudioBufferSourceNode | null>(null);
  const [copied, setCopied] = useState(false);

  const nextStepLabel = t.aiLab.nextStep;

  // Load threads from localStorage on mount
  useEffect(() => {
    try {
      const savedThreads = localStorage.getItem('protoi-threads');
      const savedActiveId = localStorage.getItem('protoi-active-thread');
      if (savedThreads) {
        const parsed = JSON.parse(savedThreads);
        setThreads(parsed);
        if (savedActiveId && parsed.some((t: Thread) => t.id === savedActiveId)) {
          setActiveThreadId(savedActiveId);
        }
      }
    } catch (e) {
      console.error('Error loading threads from localStorage:', e);
    }
  }, []);

  // Save threads to localStorage when they change
  useEffect(() => {
    if (threads.length > 0) {
      localStorage.setItem('protoi-threads', JSON.stringify(threads));
    } else {
      localStorage.removeItem('protoi-threads');
    }
  }, [threads]);

  // Save active thread ID to localStorage
  useEffect(() => {
    if (activeThreadId) {
      localStorage.setItem('protoi-active-thread', activeThreadId);
    } else {
      localStorage.removeItem('protoi-active-thread');
    }
  }, [activeThreadId]);

  // Load build sessions from localStorage on mount
  useEffect(() => {
    try {
      const savedSessions = localStorage.getItem('protoi-build-sessions');
      if (savedSessions) {
        const parsed = JSON.parse(savedSessions);
        setBuildSessions(parsed);
      }
    } catch (e) {
      console.error('Error loading build sessions from localStorage:', e);
    }
  }, []);

  // Save build sessions to localStorage when they change
  useEffect(() => {
    if (buildSessions.length > 0) {
      localStorage.setItem('protoi-build-sessions', JSON.stringify(buildSessions));
    } else {
      localStorage.removeItem('protoi-build-sessions');
    }
  }, [buildSessions]);

  // Auto-save current build session when pipeline or step changes
  useEffect(() => {
    if (mode === 'builder') {
      updateCurrentSession();
    }
  }, [pipeline, builderStep, mode]);

  // Auto-scroll chat
  useEffect(() => {
    chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [chatMessages]);

  // Load UI preview from localStorage on mount
  useEffect(() => {
    try {
      const savedPreview = localStorage.getItem('protoi_ui_preview');
      if (savedPreview) {
        setPipeline(prev => ({ ...prev, uiPreview: savedPreview }));
      }
    } catch (e) {
      console.error('Error loading UI preview from localStorage:', e);
    }
  }, []);

  // Load preview when navigating to PRD step (3)
  useEffect(() => {
    if (builderStep === 3 && mode === 'builder' && !pipeline.uiPreview) {
      const savedPreview = localStorage.getItem('protoi_ui_preview');
      if (savedPreview) {
        setPipeline(prev => ({ ...prev, uiPreview: savedPreview }));
      }
    }
  }, [builderStep, mode, pipeline.uiPreview]);

  // Auto-generate UI Preview when reaching PRD step
  useEffect(() => {
    if (builderStep === 3 && mode === 'builder' && pipeline.prd && !pipeline.uiPreview && !isGeneratingPreview) {
      generateUIPreview();
    }
  }, [builderStep, mode, pipeline.prd, pipeline.uiPreview, isGeneratingPreview]);

  useEffect(() => {
    return () => {
      stopAudio();
      if (audioContextRef.current) {
        audioContextRef.current.close();
      }
    };
  }, []);

  const getLanguageInstruction = () => {
    return aiLabLabels.langInstructionFull;
  };

  // Use translations for common labels
  const aiLabLabels = t.aiLab;

  // ==================== EXPLORER (CHAT) LOGIC ====================

  // Create new thread and send first message
  const handleNewThread = async (initialQuery?: string) => {
    const query = initialQuery || newQueryInput.trim();
    if (!query || isChatLoading) return;

    setNewQueryInput('');
    setIsChatLoading(true);

    // Create new thread
    const newThread: Thread = {
      id: `thread-${Date.now()}`,
      title: query.slice(0, 40) + (query.length > 40 ? '...' : ''),
      messages: [{ role: 'user', content: query }],
      createdAt: Date.now()
    };

    // Add to threads (keep max 5)
    setThreads(prev => [newThread, ...prev].slice(0, 5));
    setActiveThreadId(newThread.id);

    // Generate response
    const context = GeminiService.formatContext(projects);
    const extraContextStr = extraContext.length > 0
      ? `\n\nADDITIONAL DOCUMENTS PROVIDED BY USER:\n${extraContext.map(doc => `--- ${doc.name} ---\n${doc.content}`).join('\n\n')}`
      : '';
    const langInstruction = aiLabLabels.langInstructionShort;

    const prompt = `
      ${context}
      ${extraContextStr}
      ${langInstruction}
      
      You are a Data Analyst for a Hackathon. Analyze the 320 projects provided in the dataset.
      ${extraContext.length > 0 ? `The user has uploaded ${extraContext.length} additional document(s) above - use them to enrich your analysis when relevant.` : ''}
      
      USER QUESTION: ${query}
      
      CRITICAL INSTRUCTIONS:
      1. Be concise. Keep answers short (max 3-4 sentences unless requested otherwise).
      2. Do NOT summarize the dataset unless explicitly asked.
      3. Use bullet points for readability.
      4. If the user asks for "ideas" or "trends", give 3 specific examples max.
      5. Do not repeat general info. Go straight to the specific answer.
    `;

    // Use streaming - update thread with partial content as it arrives
    const response = await geminiService.generateContentStream(
      prompt,
      (partialText) => {
        setThreads(prev => prev.map(t =>
          t.id === newThread.id
            ? { ...t, messages: [t.messages[0], { role: 'assistant', content: partialText }] }
            : t
        ));
      },
      'gemini-2.5-flash'
    );

    // Final update with complete response
    setThreads(prev => prev.map(t =>
      t.id === newThread.id
        ? { ...t, messages: [t.messages[0], { role: 'assistant', content: response }] }
        : t
    ));
    setIsChatLoading(false);
  };

  // Continue conversation in active thread
  const handleFollowUp = async () => {
    if (!followUpInput.trim() || isChatLoading || !activeThreadId) return;

    const userMessage = followUpInput.trim();
    setFollowUpInput('');

    // Add user message to thread
    setThreads(prev => prev.map(t =>
      t.id === activeThreadId
        ? { ...t, messages: [...t.messages, { role: 'user', content: userMessage }] }
        : t
    ));
    setIsChatLoading(true);

    const context = GeminiService.formatContext(projects);
    const extraContextStr = extraContext.length > 0
      ? `\n\nADDITIONAL DOCUMENTS PROVIDED BY USER:\n${extraContext.map(doc => `--- ${doc.name} ---\n${doc.content}`).join('\n\n')}`
      : '';
    const langInstruction = aiLabLabels.langInstructionShort;

    // Get conversation history from active thread
    const thread = threads.find(t => t.id === activeThreadId);
    const conversationHistory = thread?.messages
      .slice(-6)
      .map(m => `${m.role.toUpperCase()}: ${m.content}`)
      .join('\n') || '';

    const prompt = `
      ${context}
      ${extraContextStr}
      ${langInstruction}
      
      You are a Data Analyst for a Hackathon. Analyze the 320 projects provided in the dataset.
      ${extraContext.length > 0 ? `The user has uploaded ${extraContext.length} additional document(s) above - use them to enrich your analysis when relevant.` : ''}
      
      CONVERSATION HISTORY:
      ${conversationHistory}
      
      NEW USER QUESTION: ${userMessage}
      
      CRITICAL INSTRUCTIONS:
      1. Be concise. Keep answers short (max 3-4 sentences unless requested otherwise).
      2. Do NOT summarize the dataset unless explicitly asked.
      3. Use bullet points for readability.
      4. If the user asks for "ideas" or "trends", give 3 specific examples max.
      5. Do not repeat general info. Go straight to the specific answer.
    `;

    // Use streaming - update thread with partial content as it arrives
    const currentThread = threads.find(t => t.id === activeThreadId);
    const currentMessages = currentThread?.messages || [];

    const response = await geminiService.generateContentStream(
      prompt,
      (partialText) => {
        setThreads(prev => prev.map(t =>
          t.id === activeThreadId
            ? { ...t, messages: [...currentMessages, { role: 'user', content: userMessage }, { role: 'assistant', content: partialText }] }
            : t
        ));
      },
      'gemini-2.5-flash'
    );

    // Final update with complete response
    setThreads(prev => prev.map(t =>
      t.id === activeThreadId
        ? { ...t, messages: [...currentMessages, { role: 'user', content: userMessage }, { role: 'assistant', content: response }] }
        : t
    ));
    setIsChatLoading(false);
  };

  const deleteThread = (threadId: string) => {
    setThreads(prev => prev.filter(t => t.id !== threadId));
    if (activeThreadId === threadId) {
      setActiveThreadId(threads.length > 1 ? threads.find(t => t.id !== threadId)?.id || null : null);
    }
  };

  const convertChatToIdea = () => {
    const lastAssistantMsg = [...chatMessages].reverse().find(m => m.role === 'assistant');
    if (lastAssistantMsg) {
      setIdeaInput(lastAssistantMsg.content); // Pre-fill idea input
      setMode('builder');
      setBuilderStep(0); // Start at platform selection
    }
  };

  // ==================== BUILDER (PIPELINE) LOGIC ====================

  // Build Session Management Functions
  const saveBuildSession = (name?: string) => {
    const sessionName = name || saveSessionName.trim() || `Build Session ${new Date().toLocaleString()}`;
    const newSession: BuildSession = {
      id: `build-${Date.now()}`,
      name: sessionName,
      pipeline: { ...pipeline },
      builderStep,
      createdAt: Date.now(),
      updatedAt: Date.now()
    };

    setBuildSessions(prev => [newSession, ...prev].slice(0, 10)); // Keep max 10 sessions
    setSaveSessionName(''); // Clear input
    return newSession.id;
  };

  const loadBuildSession = (sessionId: string) => {
    const session = buildSessions.find(s => s.id === sessionId);
    if (session) {
      const loadedPipeline = { ...session.pipeline };

      // If session doesn't have preview but there's one in localStorage, load it
      if (!loadedPipeline.uiPreview) {
        const savedPreview = localStorage.getItem('protoi_ui_preview');
        if (savedPreview) {
          loadedPipeline.uiPreview = savedPreview;
        }
      }

      setPipeline(loadedPipeline);
      setBuilderStep(session.builderStep);
      setMode('builder');
      setShowBuildHistory(false);
    }
  };

  const deleteBuildSession = (sessionId: string) => {
    setBuildSessions(prev => prev.filter(s => s.id !== sessionId));
  };

  const updateCurrentSession = () => {
    // Auto-save current session if it has meaningful content
    if (pipeline.platform || pipeline.idea || pipeline.validation || pipeline.prd) {
      const existingSession = buildSessions.find(s =>
        s.pipeline.platform === pipeline.platform &&
        s.pipeline.idea === pipeline.idea
      );

      if (existingSession) {
        // Update existing session
        setBuildSessions(prev => prev.map(s =>
          s.id === existingSession.id
            ? { ...s, pipeline: { ...pipeline }, builderStep, updatedAt: Date.now() }
            : s
        ));
      } else if (pipeline.idea) {
        // Create new auto-saved session
        saveBuildSession(`Auto-saved: ${pipeline.idea.slice(0, 30)}...`);
      }
    }
  };

  const handlePlatformSelect = (p: PlatformType) => {
    // When changing platform, clear all subsequent steps since they depend on the platform
    setPipeline(prev => ({
      ...prev,
      platform: p,
      idea: null,
      validation: null,
      prd: null,
      masterPrompt: null,
      uiPreview: null
    }));
    // Clear preview from localStorage since platform changed
    localStorage.removeItem('protoi_ui_preview');
    setBuilderStep(1);
  };

  const generateStep = async (step: 'idea' | 'validation' | 'prd' | 'prompt', luckyMode = false) => {
    setIsGenerating(true);
    stopAudio();

    // Select Model based on complexity
    const modelToUse = step === 'idea' ? FAST_MODEL : REASONING_MODEL;

    const context = GeminiService.formatContext(projects);
    const extraContextStr = extraContext.length > 0
      ? `\n\nADDITIONAL DOCUMENTS PROVIDED BY USER:\n${extraContext.map(doc => `--- ${doc.name} ---\n${doc.content}`).join('\n\n')}`
      : '';
    // Use different language instructions: Builder steps use langInstructionBuilder (no Master Prompt mention)
    // Only the final 'prompt' step uses langInstructionFull
    const langInstruction = step === 'prompt' ? aiLabLabels.langInstructionFull : aiLabLabels.langInstructionBuilder;
    const platformInfo = t.platforms[pipeline.platform || 'google'];
    let prompt = '';

    if (step === 'idea') {
      prompt = `
        ${context}
        ${extraContextStr}
        ${langInstruction}
        
        CONTEXT:
        The user has selected the platform: ${platformInfo.title}.
        Platform Strengths: ${platformInfo.strengths}
        Platform Limitations: ${platformInfo.limitations}
        ${extraContext.length > 0 ? `The user has uploaded ${extraContext.length} additional document(s) above - consider them when generating ideas.` : ''}
        
        TASK:
        ${luckyMode
          ? "Analyze the dataset for 'Blue Ocean' gaps (unsolved problems) and generate a killer Hackathon idea that fits the platform's strengths."
          : `Refine the user's intuition: "${ideaInput}". Ensure it fits the platform's constraints and stands out from the dataset.`}
        
        OUTPUT FORMAT (Markdown):
        # ðŸ’¡ Concept: [Name]
        **The Pitch:** [Narrative hook]
        **Why this Platform:** Explain why ${platformInfo.title} is perfect for this (e.g. "Because this requires complex reasoning..." or "Because this needs rapid UI...").
        **Viability Check:** Can this be built in 72h on this platform? (Be honest about risks).
      `;
    } else if (step === 'validation') {
      prompt = `
        ${langInstruction}
        
        IDEA:
        ${pipeline.idea}
        
        PLATFORM: ${pipeline.platform}
        
        TASK:
        Perform a Market & Tech Validation.
        
        OUTPUT FORMAT (Markdown):
        # ðŸ“Š Validation Analysis
        **Market Opportunity:** Size, urgency, user pain points.
        **Competitive Landscape:** Compare with the provided dataset. What makes this unique?
        **Platform Fit Risk:** Specific technical risks of building THIS idea on ${pipeline.platform}.
        
        ## ðŸ’€ Brutal Feedback (No Filters)
        [Act as a cynical Senior Engineer & VC. Tear this idea apart. Why might it fail? What are the hard truths the user is ignoring? Be direct, almost harsh, but constructive. Identify "hand-wavy" logic or technical impossibilities for a hackathon timeframe.]

        **Verdict:** [Viable / Risky / Pivot Needed]
      `;
    } else if (step === 'prd') {
      prompt = `
        ${langInstruction}
        
        IDEA: ${pipeline.idea}
        VALIDATION: ${pipeline.validation}
        PLATFORM: ${pipeline.platform}
        
        TASK:
        Draft a High-Level Conceptual PRD. DO NOT write code. DO NOT list specific libraries unless native to the platform.
        Focus on "WHAT" needs to be built, let the platform decide "HOW".
        
        OUTPUT FORMAT (Markdown):
        # ðŸ“ Conceptual PRD
        **1. Executive Summary:** The vision.
        **2. Core Features (MoSCoW):** Must have vs Nice to have.
        **3. User Flow:** Narrative walkthrough of the demo.
        **4. AI Touchpoints:** Where exactly is GenAI used? (Reasoning, Image generation, etc.)
        **5. Data Needs:** What data is input/output?
      `;
    } else if (step === 'prompt') {
      // MASTER PROMPT IS ALWAYS IN ENGLISH FOR THE TOOLS
      const uiPreviewCode = `\n\nUI PREVIEW CODE (Use this as design reference):\n${pipeline.uiPreview}`;

      prompt = `
        CONTEXT:
        We are building a hackathon project on: ${platformInfo.title}.
        
        INPUTS:
        Idea: ${pipeline.idea}
        PRD: ${pipeline.prd}${uiPreviewCode}
        
        TASK:
        Create a single, structured MASTER PROMPT in ENGLISH that I can copy-paste into ${platformInfo.title}'s AI chat to build this app.
        
        The prompt should:
        1. Set the role (Senior Engineer).
        2. Describe the app goal and user flow clearly.
        3. List key features from the PRD.
        4. If UI preview code is provided above, explicitly reference it and tell ${platformInfo.title} to use it as design inspiration and reference for the visual style, colors, layout, and components.
        5. Explicitly tell ${platformInfo.title} to make technical choices (stack, styling) based on its own best practices.
        6. Emphasize "Speed to Demo" and "Robustness".
        
        OUTPUT FORMAT (Markdown):
        # ðŸš€ Master Prompt for ${platformInfo.title}
        
        \`\`\`text
        [The full prompt goes here...]
        \`\`\`
        
        **Next Steps:**
        1. Copy the code block above.
        2. Go to ${platformInfo.title}.
        3. Paste and run.
      `;
    }

    let accumulatedText = '';
    const result = await geminiService.generateContentStream(
      prompt,
      (chunkText) => {
        // Acumular el texto progresivamente para evitar saltos
        accumulatedText += chunkText;
        setStreamingContent(accumulatedText);
      },
      modelToUse
    );

    // Clear dependent steps when regenerating an intermediate step
    const updates: Partial<Pipeline> = {
      [step === 'prompt' ? 'masterPrompt' : step]: result
    };

    if (step === 'idea') {
      // Clear all subsequent steps
      updates.validation = null;
      updates.prd = null;
      updates.masterPrompt = null;
      updates.uiPreview = null;
      localStorage.removeItem('protoi_ui_preview');
    } else if (step === 'validation') {
      // Clear PRD and subsequent steps
      updates.prd = null;
      updates.masterPrompt = null;
      updates.uiPreview = null;
      localStorage.removeItem('protoi_ui_preview');
    } else if (step === 'prd') {
      // Clear master prompt (it depends on PRD and uiPreview)
      updates.masterPrompt = null;
      // Note: uiPreview depends on PRD, but since it's generated in the same step, don't clear it here
    }
    // If step === 'prompt', don't clear anything

    setPipeline(prev => ({
      ...prev,
      ...updates
    }));

    setStreamingContent(''); // Clear streaming content
    setIsGenerating(false);
  };

  // Auto-advance to next step AND trigger generation
  const advanceAndGenerate = async (nextStep: number, generateType: 'validation' | 'prd' | 'prompt') => {
    setBuilderStep(nextStep);
    // Small delay to allow UI to update before starting generation
    setTimeout(() => {
      generateStep(generateType);
    }, 100);
  };

  // Handle Enter key in idea textarea
  const handleIdeaKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey && ideaInput.trim() && !isGenerating) {
      e.preventDefault();
      generateStep('idea', false);
    }
  };

  // Generate UI Preview using Flash UI style prompts
  const generateUIPreview = async () => {
    if (!pipeline.prd || isGeneratingPreview) return;

    setIsGeneratingPreview(true);
    setPipeline(prev => ({ ...prev, uiPreview: null }));
    setPreviewTypewriterText(''); // Reset typewriter text

    try {
      // Step 1: Generate a creative design direction (Flash UI style)
      const stylePrompt = `
Generate ONE highly evocative design direction for this hackathon app concept:

**APP CONCEPT:**
${pipeline.idea}

**KEY FEATURES:**
${pipeline.prd}

**STRICT IP SAFEGUARD:**
Never use artist or brand names. Use physical and material metaphors.

**CREATIVE EXAMPLES (Do not copy these, use them as tone guide):**
- "Asymmetrical Rectilinear Blockwork" (Grid-heavy, primary pigments, thick structural strokes).
- "Grainy Risograph Layering" (Tactile paper texture, overprinted translucent inks).
- "Kinetic Wireframe Suspension" (Floating silhouettes, thin balancing lines).
- "Spectral Prismatic Diffusion" (Glassmorphism, caustic refraction, morphing gradients).

**GOAL:**
Return ONLY one creative style name (e.g. "Tactile Risograph Press"). Just the name, nothing else.
      `.trim();

      const styleResponse = await geminiService.generateContent(stylePrompt, 'gemini-3-flash-preview');
      const styleName = styleResponse.trim().replace(/['"]/g, '');

      // Step 2: Generate HTML using Flash UI prompt style
      const userLanguage = language === 'es' ? 'Spanish' : 'English';
      const htmlPrompt = `
You are Flash UI. Create a stunning, high-fidelity UI mockup for this hackathon app.

**APP CONCEPT:**
${pipeline.idea}

**KEY FEATURES (from PRD):**
${pipeline.prd}

**CONCEPTUAL DIRECTION: ${styleName}**

**LANGUAGE REQUIREMENT:**
All text content, labels, buttons, and user interface elements must be in ${userLanguage}. Use appropriate ${userLanguage} terminology and phrasing.

**VISUAL EXECUTION RULES:**
1. **Materiality**: Use the specified metaphor to drive every CSS choice. (e.g. if Risograph, use \`feTurbulence\` for grain and \`mix-blend-mode: multiply\` for ink layering).
2. **Typography**: Use Google Fonts (import them). Pair a bold sans-serif with a refined monospace for data.
3. **Motion**: Include subtle, high-performance CSS animations (hover transitions, entry reveals).
4. **IP SAFEGUARD**: No artist names or trademarks. 
5. **Layout**: Be bold with negative space and hierarchy. Avoid generic cards.
6. **Completeness**: Show a realistic main screen with placeholder data that makes sense for the app concept.

Return ONLY RAW HTML starting with <!DOCTYPE html>. Include all CSS in <style> tags. No markdown fences.
      `.trim();

      let accumulatedHtml = '';
      const result = await geminiService.generateContentStream(
        htmlPrompt,
        (chunkText) => {
          // Acumulador como en Flash UI
          accumulatedHtml += chunkText;
          setPipeline(prev => ({ ...prev, uiPreview: accumulatedHtml }));

          // Typewriter effect for the preview overlay
          const currentText = previewTypewriterText;
          const newText = accumulatedHtml;
          const charsToAdd = newText.slice(currentText.length);

          if (charsToAdd.length > 0) {
            let charIndex = 0;
            const typeChar = () => {
              if (charIndex < charsToAdd.length) {
                setPreviewTypewriterText(currentText + charsToAdd.slice(0, charIndex + 1));
                charIndex++;
                setTimeout(typeChar, 10); // 10ms delay between characters
              }
            };
            typeChar();
          }
        },
        'gemini-3-flash-preview'
      );

      // Final cleanup
      let finalHtml = result.trim();
      if (finalHtml.startsWith('```html')) finalHtml = finalHtml.substring(7).trimStart();
      if (finalHtml.startsWith('```')) finalHtml = finalHtml.substring(3).trimStart();
      if (finalHtml.endsWith('```')) finalHtml = finalHtml.substring(0, finalHtml.length - 3).trimEnd();

      setPipeline(prev => ({ ...prev, uiPreview: finalHtml }));
      setPreviewTypewriterText(finalHtml); // Set final text

      // Guardar el preview en localStorage para persistencia
      localStorage.setItem('protoi_ui_preview', finalHtml);
    } catch (error) {
      console.error('Error generating UI preview:', error);
      const errorHtml = `<div style="color: #ff6b6b; padding: 20px; font-family: monospace;">Error generating preview</div>`;
      setPipeline(prev => ({
        ...prev,
        uiPreview: errorHtml
      }));
      setPreviewTypewriterText(errorHtml);
    } finally {
      setIsGeneratingPreview(false);
    }
  };

  const resetPipeline = () => {
    setBuilderStep(0);
    setPipeline({ platform: null, idea: null, validation: null, prd: null, masterPrompt: null, uiPreview: null });
    setIdeaInput('');
    stopAudio();
    // Limpiar el preview del localStorage al resetear
    localStorage.removeItem('protoi_ui_preview');
  };

  const exportPipeline = () => {
    const content = `# Hackathon Builder Pipeline
Platform: ${pipeline.platform}
Date: ${new Date().toLocaleString()}

## 1. IDEA
${pipeline.idea}

## 2. VALIDATION
${pipeline.validation}

## 3. CONCEPTUAL PRD
${pipeline.prd}

## 4. MASTER PROMPT
${pipeline.masterPrompt}
`;
    const blob = new Blob([content], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `hackathon-plan-${Date.now()}.md`;
    a.click();
    URL.revokeObjectURL(url);
  };

  // --- AUDIO LOGIC ---
  const stopAudio = () => {
    if (audioSourceRef.current) {
      audioSourceRef.current.stop();
      audioSourceRef.current = null;
    }
    setIsPlaying(false);
  };

  const handlePlayAudio = async () => {
    if (isPlaying) { stopAudio(); return; }

    const content = mode === 'explorer'
      ? chatMessages[chatMessages.length - 1]?.content
      : (builderStep === 1 ? pipeline.idea : builderStep === 2 ? pipeline.validation : builderStep === 3 ? pipeline.prd : pipeline.masterPrompt);

    if (!content) return;

    try {
      setIsGeneratingAudio(true);
      if (!audioContextRef.current) {
        audioContextRef.current = new (window.AudioContext || (window as any).webkitAudioContext)({ sampleRate: 24000 });
      }
      if (audioContextRef.current.state === 'suspended') await audioContextRef.current.resume();

      const base64Audio = await geminiService.generateSpeech(content, language);
      if (base64Audio) {
        const audioBuffer = await decodeAudioData(decode(base64Audio), audioContextRef.current, 24000, 1);
        const source = audioContextRef.current.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(audioContextRef.current.destination);
        source.onended = () => setIsPlaying(false);
        source.start();
        audioSourceRef.current = source;
        setIsPlaying(true);
      }
    } catch (err) { console.error(err); }
    finally { setIsGeneratingAudio(false); }
  };

  const handleCopy = () => {
    const content = pipeline.masterPrompt || '';
    // Try to extract content inside code block if exists
    const codeMatch = content.match(/```text\n([\s\S]*?)\n```/);
    const textToCopy = codeMatch ? codeMatch[1] : content;

    navigator.clipboard.writeText(textToCopy);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  const renderPlatformCard = (key: 'v0' | 'lovable' | 'google', Icon: any) => {
    const p = t.platforms[key];
    const isSelected = pipeline.platform === key;
    return (
      <button
        onClick={() => handlePlatformSelect(key)}
        className={`w-full p-2 flex items-center gap-3 transition-all text-left ${isSelected
          ? 'bg-yellow-400/10 border border-yellow-400'
          : 'bg-basalt-900 border border-basalt-700 hover:border-yellow-400/50'
          }`}
      >
        <Icon className={`w-4 h-4 flex-shrink-0 ${isSelected ? 'text-yellow-400' : 'text-gray-500'}`} />
        <div className="flex-1 min-w-0">
          <div className="flex items-center gap-2">
            <span className="text-white font-bold text-xs font-mono">{p.title}</span>
          </div>
        </div>
        {isSelected && <Check className="w-3 h-3 text-yellow-400 flex-shrink-0" />}
      </button>
    );
  };

  return (
    <div className="flex flex-col md:grid md:grid-cols-12 gap-3 md:gap-6 h-full min-h-0">

      {/* LEFT COLUMN: CONTROLS - Compact on mobile, scrollable on desktop */}
      <aside className="md:col-span-5 lg:col-span-4 xl:col-span-3 flex flex-col gap-2 flex-shrink-0 md:min-h-0 md:overflow-y-auto custom-scrollbar">

        {/* Mode Switcher - Always visible */}
        <div className="flex border-2 border-basalt-700 flex-shrink-0">
          <button
            onClick={() => setMode('explorer')}
            className={`flex-1 py-1.5 md:py-2 font-mono font-bold uppercase text-[9px] md:text-[10px] tracking-wider transition-all flex items-center justify-center gap-1 md:gap-1.5 whitespace-nowrap ${mode === 'explorer'
              ? 'bg-yellow-400 text-black'
              : 'text-gray-400 hover:text-white'
              }`}
          >
            <MessageSquare className="w-3 h-3 flex-shrink-0" />
            <span>{aiLabLabels.data}</span>
          </button>
          <button
            onClick={() => setMode('builder')}
            className={`flex-1 py-1.5 md:py-2 font-mono font-bold uppercase text-[9px] md:text-[10px] tracking-wider transition-all flex items-center justify-center gap-1 md:gap-1.5 whitespace-nowrap ${mode === 'builder'
              ? 'bg-yellow-400 text-black'
              : 'text-gray-400 hover:text-white'
              }`}
          >
            <Rocket className="w-3 h-3 flex-shrink-0" />
            <span>{aiLabLabels.build}</span>
          </button>
          {mode === 'builder' && (
            <button
              onClick={() => setShowBuildHistory(true)}
              className="p-1.5 md:p-2 border border-basalt-700 text-gray-400 hover:border-yellow-400 hover:text-white transition-all flex items-center justify-center"
              title="Build History"
            >
              <History className="w-3 h-3" />
            </button>
          )}
        </div>

        {/* New Query Input - Explorer mode */}
        {mode === 'explorer' && (
          <div className="flex gap-1.5 flex-shrink-0">
            <input
              type="text"
              value={newQueryInput}
              onChange={(e) => setNewQueryInput(e.target.value)}
              onKeyDown={(e) => e.key === 'Enter' && !e.shiftKey && handleNewThread()}
              placeholder={aiLabLabels.newQuestion}
              disabled={isChatLoading}
              className="flex-1 bg-basalt-800 border border-basalt-700 p-2 font-mono text-xs text-white focus:border-yellow-400 outline-none transition-colors placeholder:text-yellow-400/50"
            />
            <button
              onClick={() => handleNewThread()}
              disabled={isChatLoading || !newQueryInput.trim()}
              className="bg-yellow-400 text-black px-3 font-bold hover:bg-yellow-300 transition-colors disabled:opacity-50"
              title={aiLabLabels.newThread}
            >
              {isChatLoading && !activeThreadId ? <Loader2 className="w-4 h-4 animate-spin" /> : <Plus className="w-4 h-4" />}
            </button>
          </div>
        )}

        {/* Context Badge - Only in Explorer */}
        {mode === 'explorer' && (
          <div className="bg-basalt-900 border border-basalt-700 p-2 flex items-center gap-2 flex-shrink-0">
            <Database className="w-3 h-3 text-yellow-400" />
            <span className="font-mono text-[9px] text-gray-400">
              <span className="text-yellow-400">{projects.length}</span> projects loaded from AI Studio Global Hackathon
            </span>
          </div>
        )}

        {mode === 'explorer' ? (
          // EXPLORER CONTROLS - Thread-based Chat
          <div className="flex-1 min-h-0 flex flex-col gap-2 animate-slide-up">

            {/* Quick Queries - Create new threads */}
            <div className="grid grid-cols-2 sm:grid-cols-4 gap-1 flex-shrink-0">
              <button
                onClick={() => handleNewThread(aiLabLabels.topTechnologies)}
                disabled={isChatLoading}
                className="p-1.5 md:p-2 border border-basalt-700 text-[9px] text-gray-400 hover:border-yellow-400 hover:text-white transition-all flex items-center sm:flex-col justify-center gap-1 sm:gap-0.5 font-mono disabled:opacity-50"
              >
                <Zap className="w-3 h-3 text-yellow-400" />
                <span>TECH</span>
              </button>
              <button
                onClick={() => handleNewThread(aiLabLabels.gapsOpportunities)}
                disabled={isChatLoading}
                className="p-1.5 md:p-2 border border-basalt-700 text-[9px] text-gray-400 hover:border-yellow-400 hover:text-white transition-all flex items-center sm:flex-col justify-center gap-1 sm:gap-0.5 font-mono disabled:opacity-50"
              >
                <Target className="w-3 h-3 text-green-400" />
                <span>GAPS</span>
              </button>
              <button
                onClick={() => handleNewThread(aiLabLabels.emergingTrends)}
                disabled={isChatLoading}
                className="p-1.5 md:p-2 border border-basalt-700 text-[9px] text-gray-400 hover:border-yellow-400 hover:text-white transition-all flex items-center sm:flex-col justify-center gap-1 sm:gap-0.5 font-mono disabled:opacity-50"
              >
                <Sparkles className="w-3 h-3 text-purple-400" />
                <span>TREND</span>
              </button>
              <button
                onClick={() => handleNewThread(aiLabLabels.innovativeIdeas)}
                disabled={isChatLoading}
                className="p-1.5 md:p-2 border border-basalt-700 text-[9px] text-gray-400 hover:border-yellow-400 hover:text-white transition-all flex items-center sm:flex-col justify-center gap-1 sm:gap-0.5 font-mono disabled:opacity-50"
              >
                <Lightbulb className="w-3 h-3 text-orange-400" />
                <span>IDEAS</span>
              </button>
            </div>

            {/* Thread History - Horizontal scroll on mobile, vertical on desktop */}
            {threads.length > 0 && (
              <div className="flex flex-col gap-1 flex-shrink-0 md:flex-1 md:min-h-0 md:overflow-y-auto custom-scrollbar">
                <div className="flex items-center justify-between py-1">
                  <div className="flex items-center gap-2">
                    <History className="w-3 h-3 text-gray-500" />
                    <span className="font-mono text-[9px] text-gray-500 uppercase">
                      {aiLabLabels.history} ({threads.length})
                    </span>
                  </div>
                </div>
                {/* Mobile: horizontal scroll / Desktop: vertical list */}
                <div className="flex md:flex-col gap-1.5 overflow-x-auto md:overflow-x-visible pb-2 md:pb-0 -mx-1 px-1">
                  {threads.map((thread) => (
                    <button
                      key={thread.id}
                      onClick={() => setActiveThreadId(thread.id)}
                      className={`group flex-shrink-0 w-[140px] md:w-full p-1.5 md:p-2 text-left transition-all flex items-center gap-2 ${activeThreadId === thread.id
                        ? 'bg-yellow-400/10 border border-yellow-400'
                        : 'bg-basalt-900 border border-basalt-700 hover:border-basalt-600'
                        }`}
                    >
                      <MessageSquare className={`w-3 h-3 flex-shrink-0 ${activeThreadId === thread.id ? 'text-yellow-400' : 'text-gray-600'
                        }`} />
                      <div className="flex-1 min-w-0">
                        <p className={`font-mono text-[9px] md:text-[10px] truncate ${activeThreadId === thread.id ? 'text-white' : 'text-gray-400'
                          }`}>
                          {thread.title}
                        </p>
                      </div>
                      <button
                        onClick={(e) => { e.stopPropagation(); deleteThread(thread.id); }}
                        className="p-0.5 text-gray-600 hover:text-red-400 transition-all"
                      >
                        <X className="w-3 h-3" />
                      </button>
                    </button>
                  ))}
                </div>
              </div>
            )}

            {/* Convert to Builder */}
            {chatMessages.length > 0 && (
              <button
                onClick={convertChatToIdea}
                className="w-full bg-yellow-400 text-black p-2 font-mono font-bold text-[10px] flex items-center justify-center gap-2 hover:bg-yellow-300 transition-colors flex-shrink-0"
              >
                {t.useInsight}
                <ArrowRight className="w-3 h-3" />
              </button>
            )}
          </div>
        ) : (
          // BUILDER CONTROLS - Compact Pipeline
          <div className="flex-1 min-h-0 flex flex-col gap-3 animate-fade-in">
            {/* Stepper - Horizontal Row with Labels */}
            <div className="flex-shrink-0 space-y-2">
              <div className="flex gap-1">
                {[1, 2, 3, 4, 5].map((num, idx) => {
                  // Determine if this step is clickable
                  // Step 0 (platform) is always accessible
                  // Other steps are accessible if they have content or if we've reached them
                  const hasStepContent =
                    (idx === 1 && pipeline.idea) ||
                    (idx === 2 && pipeline.validation) ||
                    (idx === 3 && pipeline.prd) ||
                    (idx === 4 && pipeline.masterPrompt);

                  const isClickable = (idx === 0 && (!pipeline.platform || builderStep > 0)) || hasStepContent || (idx <= builderStep && !isGenerating && !isGeneratingPreview);

                  return (
                    <button
                      key={idx}
                      onClick={() => {
                        if (isClickable) {
                          setBuilderStep(idx);

                          // Load preview from localStorage when navigating to PRD step (3) if it has content
                          if (idx === 3 && pipeline.prd && !pipeline.uiPreview) {
                            const savedPreview = localStorage.getItem('protoi_ui_preview');
                            if (savedPreview) {
                              setPipeline(prev => ({ ...prev, uiPreview: savedPreview }));
                            }
                          }
                        }
                      }}
                      disabled={!isClickable}
                      className={`flex-1 py-1.5 text-[9px] font-mono font-bold transition-all ${idx === builderStep ? 'bg-yellow-400 text-black' :
                        (idx < builderStep || hasStepContent) ? 'bg-basalt-800 border border-green-400 text-green-400 hover:bg-green-400/10 cursor-pointer' :
                          'bg-basalt-800 border border-basalt-700 text-gray-600 cursor-not-allowed'
                        }`}
                    >
                      {idx < builderStep ? 'âœ“' : num}
                    </button>
                  );
                })}
              </div>
              {/* Step Description */}
              <div className="bg-basalt-900/50 border border-basalt-700 p-2">
                <div className="flex items-center gap-2">
                  {isGenerating && <Loader2 className="w-3 h-3 text-yellow-400 animate-spin" />}
                  <span className="font-mono text-[9px] text-gray-400">
                    {builderStep === 0 && aiLabLabels.stepDescPlatform}
                    {builderStep === 1 && (isGenerating ? aiLabLabels.generatingIdea : aiLabLabels.stepDescIdea)}
                    {builderStep === 2 && (isGenerating ? aiLabLabels.generatingValidation : (pipeline.validation ? `âœ“ ${aiLabLabels.validationComplete}` : aiLabLabels.stepDescValidation))}
                    {builderStep === 3 && (isGenerating ? aiLabLabels.generatingPRD : (pipeline.prd ? `âœ“ ${aiLabLabels.prdComplete}` : aiLabLabels.stepDescPRD))}
                    {builderStep === 4 && (isGenerating ? aiLabLabels.generatingPrompt : (pipeline.masterPrompt ? `âœ“ ${aiLabLabels.readyToDeploy}` : aiLabLabels.stepDescPrompt))}
                  </span>
                </div>
              </div>
            </div>

            {/* Build Content - Scrollable */}
            <div className="flex-1 min-h-0 overflow-y-auto custom-scrollbar space-y-2">

              {/* Step 0: Platform Selection */}
              {builderStep === 0 && (
                <div className="space-y-1.5 animate-slide-up">
                  <span className="font-mono text-[9px] text-gray-500 block">SELECT_PLATFORM:</span>
                  {renderPlatformCard('v0', LayoutTemplate)}
                  {renderPlatformCard('lovable', Layers)}
                  {renderPlatformCard('google', Code2)}
                </div>
              )}

              {/* Step 1: Idea Input */}
              {builderStep === 1 && (
                <div className="space-y-2 animate-slide-up">
                  <div className="flex items-center justify-between">
                    <span className="font-mono text-[9px] text-gray-500">PLATFORM: <span className="text-yellow-400">{t.platforms[pipeline.platform!].title}</span></span>
                  </div>
                  <textarea
                    value={ideaInput}
                    onChange={(e) => setIdeaInput(e.target.value)}
                    onKeyDown={handleIdeaKeyDown}
                    placeholder={t.describeIntuition}
                    className="w-full h-20 bg-basalt-800 border border-basalt-700 p-2 font-mono text-xs text-white resize-none focus:border-yellow-400 outline-none"
                    disabled={isGenerating}
                  />
                  {!pipeline.idea && (
                    <p className="text-[8px] text-gray-600 font-mono text-center">
                      {aiLabLabels.pressEnterToGen} â€¢ {aiLabLabels.orClickLucky}
                    </p>
                  )}
                  <div className="flex gap-1.5">
                    <button
                      onClick={() => generateStep('idea', false)}
                      disabled={!ideaInput || isGenerating}
                      className="flex-1 py-2 border border-basalt-700 text-white font-mono font-bold text-[10px] uppercase flex items-center justify-center gap-1 hover:border-yellow-400 disabled:opacity-50"
                    >
                      {isGenerating ? <Loader2 className="animate-spin w-3 h-3" /> : <Lightbulb className="w-3 h-3" />}
                      GEN
                    </button>
                    <button
                      onClick={() => generateStep('idea', true)}
                      disabled={isGenerating}
                      className="flex-1 py-2 bg-yellow-400 text-black font-mono font-bold text-[10px] uppercase flex items-center justify-center gap-1 disabled:opacity-50"
                    >
                      <Zap className="w-3 h-3" />
                      LUCKY
                    </button>
                  </div>
                  {pipeline.idea && (
                    <button
                      onClick={() => advanceAndGenerate(2, 'validation')}
                      className="w-full py-2 bg-green-500 text-black font-mono font-bold text-[10px] uppercase flex items-center justify-center gap-2 hover:bg-green-400 transition-colors"
                    >
                      <CheckCircle2 className="w-3 h-3" />
                      {aiLabLabels.continueValidate}
                    </button>
                  )}
                </div>
              )}

              {/* Step 2: Validation - Only show continue button when done */}
              {builderStep === 2 && pipeline.validation && !isGenerating && (
                <div className="animate-slide-up">
                  <button
                    onClick={() => advanceAndGenerate(3, 'prd')}
                    className="w-full py-2 bg-green-500 text-black font-mono font-bold text-[10px] uppercase flex items-center justify-center gap-2 hover:bg-green-400 transition-colors"
                  >
                    <CheckCircle2 className="w-3 h-3" />
                    {aiLabLabels.continuePRD}
                  </button>
                </div>
              )}

              {/* Step 3: PRD - Show preview and continue */}
              {builderStep === 3 && pipeline.prd && !isGenerating && (
                <div className="space-y-2 animate-slide-up">
                  {/* Mostrar preview si existe */}
                  {pipeline.uiPreview && (
                    <div className="relative border border-basalt-700 rounded overflow-hidden mt-2">
                      {isGeneratingPreview && (
                        <div className="generating-overlay">
                          <pre className="code-stream-preview">
                            {previewTypewriterText}
                          </pre>
                        </div>
                      )}
                      <iframe
                        srcDoc={pipeline.uiPreview}
                        title="UI Preview"
                        className="w-full h-64 md:h-80 bg-white"
                        sandbox="allow-scripts allow-forms allow-modals allow-popups allow-presentation allow-same-origin"
                      />
                      <button
                        onClick={() => setIsPreviewFullscreen(true)}
                        className="absolute top-2 right-2 bg-black/70 text-white p-1 rounded hover:bg-black/90 transition-all z-10"
                        title="Full Screen Preview"
                      >
                        <Maximize2 className="w-4 h-4" />
                      </button>
                    </div>
                  )}
                  {pipeline.uiPreview && (
                    <button
                      onClick={() => advanceAndGenerate(4, 'prompt')}
                      className="w-full py-2 bg-green-500 text-black font-mono font-bold text-[10px] uppercase flex items-center justify-center gap-2 hover:bg-green-400 transition-colors"
                    >
                      <CheckCircle2 className="w-3 h-3" />
                      {aiLabLabels.continuePrompt}
                    </button>
                  )}
                </div>
              )}

              {/* Step 4: Master Prompt - Only show actions cuando estÃ¡ listo */}
              {builderStep === 4 && pipeline.masterPrompt && !isGenerating && (
                <div className="space-y-2 animate-slide-up">
                  {/* Mostrar preview */}
                  <div className="relative border border-basalt-700 rounded overflow-hidden">
                    <iframe
                      srcDoc={pipeline.uiPreview}
                      title="UI Preview"
                      className="w-full h-64 md:h-80 bg-white"
                      sandbox="allow-scripts allow-forms allow-modals allow-popups allow-presentation allow-same-origin"
                    />
                    <button
                      onClick={() => setIsPreviewFullscreen(true)}
                      className="absolute top-2 right-2 bg-black/70 text-white p-1 rounded hover:bg-black/90 transition-all z-10"
                      title="Full Screen Preview"
                    >
                      <Maximize2 className="w-4 h-4" />
                    </button>
                  </div>
                  <button
                    onClick={() => advanceAndGenerate(4, 'prompt')}
                    className="w-full py-2 bg-green-500 text-black font-mono font-bold text-[10px] uppercase flex items-center justify-center gap-2 hover:bg-green-400 transition-colors"
                  >
                    <CheckCircle2 className="w-3 h-3" />
                    {aiLabLabels.continuePrompt}
                  </button>
                </div>
              )}

              {/* Step 4: Master Prompt - Only show actions cuando estÃ¡ listo */}
              {builderStep === 4 && pipeline.masterPrompt && !isGenerating && (
                <div className="space-y-2 animate-slide-up">
                  <div className="bg-green-500/10 border border-green-500 p-3">
                    <p className="font-mono text-[10px] text-green-400 flex items-center gap-2">
                      <CheckCircle2 className="w-4 h-4" />
                      {aiLabLabels.readyToDeploy} {aiLabLabels.copyFromTerminal}
                    </p>
                  </div>
                  <div className="flex gap-1.5">
                    <button onClick={exportPipeline} className="flex-1 py-2 border border-basalt-700 text-white text-[9px] font-mono font-bold uppercase flex items-center justify-center gap-1 hover:border-yellow-400">
                      <Download className="w-3 h-3" /> {aiLabLabels.exportAll}
                    </button>
                    <button
                      onClick={() => saveBuildSession()}
                      className="flex-1 py-2 border border-blue-500/50 text-blue-400 text-[9px] font-mono font-bold uppercase flex items-center justify-center gap-1 hover:border-blue-500"
                      disabled={!pipeline.platform && !pipeline.idea}
                    >
                      <History className="w-3 h-3" /> SAVE
                    </button>
                    <button onClick={resetPipeline} className="flex-1 py-2 border border-red-500/50 text-red-400 text-[9px] font-mono font-bold uppercase flex items-center justify-center gap-1 hover:border-red-500">
                      <Trash2 className="w-3 h-3" /> RESET
                    </button>
                  </div>
                </div>
              )}
            </div>
          </div>
        )}

      </aside>

      {/* FULLSCREEN UI PREVIEW MODAL (portal) */}
      {isPreviewFullscreen && pipeline.uiPreview && ReactDOM.createPortal(
        <div
          className="fixed inset-0 z-50 bg-black/90 backdrop-blur-sm animate-fade-in flex items-center justify-center"
          onClick={() => setIsPreviewFullscreen(false)}
        >
          <div
            className="relative w-full h-full md:w-5/6 md:h-5/6 bg-black border-2 border-basalt-700 rounded-lg overflow-hidden animate-scale-in flex flex-col"
            onClick={e => e.stopPropagation()}
          >
            <button
              onClick={() => setIsPreviewFullscreen(false)}
              className="absolute top-4 right-4 bg-black/70 text-white p-2 rounded hover:bg-black/90 z-20"
              title="Cerrar pantalla completa"
            >
              <X className="w-6 h-6" />
            </button>
            <iframe
              srcDoc={pipeline.uiPreview}
              title="UI Preview Fullscreen"
              className="w-full h-full bg-white"
              sandbox="allow-scripts allow-forms allow-modals allow-popups allow-presentation allow-same-origin"
            />
          </div>
        </div>,
        document.body
      )}

      {/* BUILD HISTORY MODAL */}
      {showBuildHistory && ReactDOM.createPortal(
        <div
          className="fixed inset-0 z-50 bg-black/90 backdrop-blur-sm animate-fade-in flex items-center justify-center p-4"
          onClick={() => setShowBuildHistory(false)}
        >
          <div
            className="relative w-full max-w-2xl bg-basalt-900 border-2 border-basalt-700 rounded-lg overflow-hidden animate-scale-in max-h-[80vh] flex flex-col"
            onClick={e => e.stopPropagation()}
          >
            <div className="flex items-center justify-between p-4 border-b border-basalt-700">
              <h3 className="font-mono text-lg font-bold text-white">BUILD HISTORY</h3>
              <button
                onClick={() => setShowBuildHistory(false)}
                className="text-gray-400 hover:text-white transition-colors"
              >
                <X className="w-6 h-6" />
              </button>
            </div>

            <div className="flex-1 overflow-y-auto p-4">
              {buildSessions.length === 0 ? (
                <div className="text-center py-8 text-gray-400">
                  <History className="w-12 h-12 mx-auto mb-4 opacity-50" />
                  <p className="font-mono text-sm">No build sessions saved yet</p>
                  <p className="font-mono text-xs text-gray-500 mt-2">Sessions are automatically saved as you build</p>
                </div>
              ) : (
                <div className="space-y-3">
                  {buildSessions.map((session) => (
                    <div key={session.id} className="bg-basalt-800 border border-basalt-700 rounded p-3 hover:border-yellow-400/50 transition-colors">
                      <div className="flex items-start justify-between">
                        <div className="flex-1 min-w-0">
                          <h4 className="font-mono text-sm font-bold text-white truncate">{session.name}</h4>
                          <div className="flex items-center gap-4 mt-1 text-xs text-gray-400">
                            <span>Step: {session.builderStep}/4</span>
                            <span>{new Date(session.updatedAt).toLocaleDateString()}</span>
                            {session.pipeline.platform && (
                              <span className="text-yellow-400">{session.pipeline.platform}</span>
                            )}
                          </div>
                          {session.pipeline.idea && (
                            <p className="text-xs text-gray-300 mt-2 line-clamp-2">{session.pipeline.idea.slice(0, 100)}...</p>
                          )}
                        </div>
                        <div className="flex items-center gap-2 ml-4">
                          <button
                            onClick={() => loadBuildSession(session.id)}
                            className="px-3 py-1 bg-yellow-400 text-black font-mono text-xs font-bold hover:bg-yellow-300 transition-colors"
                          >
                            LOAD
                          </button>
                          <button
                            onClick={() => deleteBuildSession(session.id)}
                            className="p-1 text-gray-400 hover:text-red-400 transition-colors"
                            title="Delete session"
                          >
                            <Trash2 className="w-4 h-4" />
                          </button>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>
        </div>,
        document.body
      )}

      {/* RIGHT COLUMN: THE "BASALT" TERMINAL */}
      <main className="md:col-span-7 lg:col-span-8 xl:col-span-9 min-h-0 flex flex-col flex-1">
        <div className="basalt-block flex flex-col bg-black overflow-hidden border-2 border-basalt-800 h-[280px] md:h-auto md:flex-1 md:min-h-0">

          {/* Terminal Header */}
          <div className="flex items-center justify-between bg-basalt-800 p-2 md:p-3 border-b-2 border-basalt-800 flex-shrink-0">
            <div className="flex gap-1.5 md:gap-2">
              <div className="w-2 h-2 md:w-3 md:h-3 bg-red-500"></div>
              <div className="w-2 h-2 md:w-3 md:h-3 bg-yellow-500"></div>
              <div className="w-2 h-2 md:w-3 md:h-3 bg-basalt-700"></div>
            </div>
            <div className="font-mono text-[8px] md:text-[10px] text-gray-500 uppercase tracking-wider md:tracking-widest truncate max-w-[30vw] md:max-w-none">
              {mode === 'explorer' ? 'EXPLORER.exe' : (builderStep === 0 ? 'PLATFORM' : (builderStep === 1 ? 'IDEA' : (builderStep === 2 ? 'VALIDATE' : (builderStep === 3 ? 'PRD' : 'PROMPT'))))}
            </div>
            <div className="flex items-center gap-2 md:gap-4">
              {/* Maximize button - mobile only */}
              <button
                onClick={() => setIsTerminalMaximized(true)}
                className="p-1 text-gray-500 hover:text-white transition-all md:hidden"
                title={aiLabLabels.maximize}
              >
                <Maximize2 className="w-4 h-4" />
              </button>
              <button
                onClick={handlePlayAudio}
                disabled={isGeneratingAudio}
                className={`p-1 transition-all hidden md:block ${isPlaying ? 'text-green-400' : 'text-gray-500 hover:text-white'}`}
              >
                {isGeneratingAudio ? <Loader2 className="w-4 h-4 animate-spin" /> : isPlaying ? <StopCircle className="w-4 h-4" /> : <Volume2 className="w-4 h-4" />}
              </button>
              {(builderStep === 4 && pipeline.masterPrompt) && (
                <button onClick={handleCopy} className={`p-1 transition-all ${copied ? 'text-green-400' : 'text-gray-500 hover:text-white'}`}>
                  {copied ? <Check className="w-4 h-4" /> : <Copy className="w-4 h-4" />}
                </button>
              )}
              <div className="w-2 h-2 bg-green-500 animate-pulse"></div>
            </div>
          </div>

          {/* Terminal Content */}
          <div className="flex-1 min-h-0 p-3 md:p-6 font-mono text-xs md:text-sm relative overflow-y-auto terminal-glow custom-scrollbar">
            {/* Show loading only for Chat mode without any messages yet */}
            {(isChatLoading && mode === 'explorer' && chatMessages.length === 0) ? (
              // Initial loading state for Chat
              <div className="flex flex-col items-center justify-center h-full space-y-4">
                <Loader2 className="w-10 h-10 text-green-400 animate-spin" />
                <p className="text-xs font-mono uppercase tracking-widest text-gray-500">{t.processing}</p>
                <div className="w-48 h-1 bg-basalt-800 overflow-hidden">
                  <div className="h-full bg-yellow-400 animate-progress origin-left w-full"></div>
                </div>
              </div>
            ) : (isGenerating && mode === 'builder') ? (
              // Streaming Builder content - show immediately with streaming indicator
              <div className="animate-fade-in markdown-content max-w-full overflow-x-auto">
                <div>
                  <div className="text-green-400 mb-4">&gt; EXECUTING_BUILD_PIPELINE...</div>
                  <div className="text-gray-500 mb-6">[SYSTEM] Platform: {pipeline.platform?.toUpperCase()} | Step: {builderStep}/4 | <span className="text-yellow-400 animate-pulse">streaming...</span></div>
                  {streamingContent ? (
                    <ReactMarkdown components={{
                      h1: ({ node, ...props }) => <h1 className="text-2xl font-bold text-yellow-400 mt-6 mb-4 border-b border-basalt-700 pb-2" {...props} />,
                      h2: ({ node, ...props }) => <h2 className="text-lg font-bold text-green-400 mt-6 mb-3" {...props} />,
                      strong: ({ node, ...props }) => <strong className="text-yellow-400 font-bold" {...props} />,
                      code: ({ node, ...props }) => <code className="bg-basalt-800 text-green-300 px-1.5 py-0.5 text-xs font-medium" {...props} />,
                      pre: ({ node, ...props }) => <pre className="bg-basalt-800/50 p-4 my-4 overflow-x-auto max-w-full text-xs text-green-300 border border-basalt-700 whitespace-pre-wrap" {...props} />,
                      ul: ({ node, ...props }) => <ul className="space-y-1 my-4 text-gray-300" {...props} />,
                      li: ({ node, ...props }) => <li className="pl-4 relative before:content-['+'] before:absolute before:left-0 before:text-yellow-400 before:font-bold" {...props} />
                    }}>
                      {streamingContent}
                    </ReactMarkdown>
                  ) : (
                    <div className="flex items-center gap-2 text-gray-500">
                      <Loader2 className="w-4 h-4 animate-spin text-yellow-400" />
                      <span className="animate-pulse">{t.connectingAI}</span>
                    </div>
                  )}
                </div>
              </div>
            ) : (
              <div className="animate-fade-in markdown-content max-w-full overflow-x-auto">
                {mode === 'explorer' ? (
                  chatMessages.length > 0 ? (
                    <div className="space-y-3 md:space-y-4">
                      <div className="text-green-400 text-xs md:text-sm">&gt; {activeThread?.title.slice(0, 30)}...</div>

                      {/* Full Conversation */}
                      {chatMessages.map((msg, idx) => (
                        <div key={idx} className={`${msg.role === 'user' ? 'border-l-2 border-yellow-400 pl-3 md:pl-4' : ''}`}>
                          <span className={`font-mono text-[9px] md:text-[10px] uppercase ${msg.role === 'user' ? 'text-yellow-400' : 'text-green-400'}`}>
                            {msg.role === 'user' ? '>' : '<'}
                          </span>
                          {msg.role === 'user' ? (
                            <p className="text-white text-xs md:text-sm mt-1 line-clamp-3 md:line-clamp-none">"{msg.content}"</p>
                          ) : (
                            <div className="text-white mt-1 md:mt-2">
                              <ReactMarkdown components={{
                                h1: ({ node, ...props }) => <h1 className="text-base md:text-xl font-bold text-yellow-400 mb-2 md:mb-3" {...props} />,
                                h2: ({ node, ...props }) => <h2 className="text-sm md:text-base font-bold text-green-400 mt-3 md:mt-4 mb-1 md:mb-2" {...props} />,
                                strong: ({ node, ...props }) => <strong className="text-yellow-400 font-bold" {...props} />,
                                ul: ({ node, ...props }) => <ul className="space-y-0.5 md:space-y-1 my-1 md:my-2" {...props} />,
                                li: ({ node, ...props }) => <li className="text-gray-300 pl-3 md:pl-4 relative before:content-['+'] before:absolute before:left-0 before:text-yellow-400 before:font-bold text-xs md:text-sm" {...props} />,
                                code: ({ node, ...props }) => <code className="bg-basalt-800 text-green-300 px-1 py-0.5 text-[10px] md:text-xs" {...props} />,
                                pre: ({ node, ...props }) => <pre className="bg-basalt-800/50 p-2 md:p-3 border border-basalt-700 my-2 md:my-3 overflow-x-auto text-[10px] md:text-xs text-green-300" {...props} />,
                                p: ({ node, ...props }) => <p className="text-xs md:text-sm text-gray-300 my-1 md:my-2" {...props} />,
                              }}>
                                {msg.content}
                              </ReactMarkdown>
                            </div>
                          )}
                          {idx < chatMessages.length - 1 && <div className="border-b border-basalt-800 my-2 md:my-4" />}
                        </div>
                      ))}
                      <div ref={chatEndRef} />
                    </div>
                  ) : (
                    <div className="flex flex-col items-center justify-center h-full text-gray-600 px-4">
                      <Terminal className="w-10 h-10 md:w-16 md:h-16 mb-3 md:mb-4 stroke-[1px]" />
                      <p className="text-[10px] md:text-xs uppercase tracking-widest text-center">
                        {aiLabLabels.readyToAnalyze}
                      </p>
                      <p className="text-[9px] md:text-[10px] text-gray-700 mt-1 md:mt-2 text-center">
                        {aiLabLabels.useLeftPanel}
                      </p>
                    </div>
                  )
                ) : (
                  // BUILDER OUTPUT
                  builderStep === 0 ? (
                    <div className="flex flex-col items-center justify-center h-full text-gray-600">
                      <Layers className="w-16 h-16 mb-4 stroke-[1px]" />
                      <p className="text-xs uppercase tracking-widest">{t.selectPlatform}</p>
                    </div>
                  ) : (
                    // Normal Builder Output
                    <div>
                      <div className="text-green-400 mb-4">&gt; EXECUTING_BUILD_PIPELINE...</div>
                      <div className="text-gray-500 mb-6">[SYSTEM] Platform: {pipeline.platform?.toUpperCase()} | Step: {builderStep}/4</div>
                      <ReactMarkdown components={{
                        h1: ({ node, ...props }) => <h1 className="text-2xl font-bold text-yellow-400 mt-6 mb-4 border-b border-basalt-700 pb-2" {...props} />,
                        h2: ({ node, ...props }) => <h2 className="text-lg font-bold text-green-400 mt-6 mb-3" {...props} />,
                        strong: ({ node, ...props }) => <strong className="text-yellow-400 font-bold" {...props} />,
                        code: ({ node, ...props }) => <code className="bg-basalt-800 text-green-300 px-1.5 py-0.5 text-xs font-medium" {...props} />,
                        pre: ({ node, ...props }) => <pre className="bg-basalt-800/50 p-4 my-4 overflow-x-auto max-w-full text-xs text-green-300 border border-basalt-700 whitespace-pre-wrap" {...props} />,
                        ul: ({ node, ...props }) => <ul className="space-y-1 my-4 text-gray-300" {...props} />,
                        li: ({ node, ...props }) => <li className="pl-4 relative before:content-['+'] before:absolute before:left-0 before:text-yellow-400 before:font-bold" {...props} />
                      }}>
                        {(builderStep === 1 ? pipeline.idea : builderStep === 2 ? pipeline.validation : builderStep === 3 ? pipeline.prd : pipeline.masterPrompt) || ''}
                      </ReactMarkdown>
                    </div>
                  )
                )}
              </div>
            )}

            {/* Terminal Cursor */}
            {!isGenerating && !isChatLoading && (
              <div className="mt-4 flex items-center">
                <span className="text-green-400">&gt;</span>
                <div className="inline-block w-2 h-5 bg-green-400 animate-pulse ml-2"></div>
              </div>
            )}
          </div>

          {/* Terminal Input - Only show in Explorer mode when thread is active */}
          {mode === 'explorer' && activeThreadId && (
            <div className="p-2 md:p-3 bg-basalt-900 border-t-2 border-basalt-800 flex items-center gap-2 flex-shrink-0">
              <span className="text-yellow-400 font-mono font-bold text-xs md:text-sm">$</span>
              <input
                type="text"
                value={followUpInput}
                onChange={(e) => setFollowUpInput(e.target.value)}
                onKeyDown={(e) => e.key === 'Enter' && !e.shiftKey && handleFollowUp()}
                className="bg-transparent border-none outline-none font-mono text-xs flex-grow text-white placeholder:text-gray-500"
                placeholder={aiLabLabels.followUp}
                disabled={isChatLoading}
              />
              <button
                onClick={handleFollowUp}
                disabled={isChatLoading || !followUpInput.trim()}
                className="bg-yellow-400 text-black p-1.5 md:p-2 disabled:opacity-50 transition-colors"
              >
                {isChatLoading ? <Loader2 className="w-4 h-4 animate-spin" /> : <Send className="w-4 h-4" />}
              </button>
            </div>
          )}
        </div>
      </main>

      {/* MAXIMIZED TERMINAL MODAL */}
      {isTerminalMaximized && (
        <div
          className="fixed inset-0 z-50 bg-black/90 backdrop-blur-sm animate-fade-in"
          onClick={() => setIsTerminalMaximized(false)}
        >
          <div
            className="absolute inset-2 md:inset-4 bg-[#0a0a0b] border-2 border-basalt-700 flex flex-col animate-scale-in"
            onClick={(e) => e.stopPropagation()}
          >
            {/* Modal Header */}
            <div className="flex items-center justify-between bg-basalt-800 p-3 border-b-2 border-basalt-700 flex-shrink-0">
              <div className="flex gap-2">
                <div className="w-3 h-3 bg-red-500"></div>
                <div className="w-3 h-3 bg-yellow-500"></div>
                <div className="w-3 h-3 bg-green-500"></div>
              </div>
              <div className="font-mono text-[10px] text-gray-500 uppercase tracking-widest">
                {mode === 'explorer' ? 'EXPLORER.exe' : `BUILDER_STEP_${builderStep}`} â€” {aiLabLabels.maximized}
              </div>
              <div className="flex items-center gap-3">
                <button
                  onClick={handlePlayAudio}
                  disabled={isGeneratingAudio}
                  className={`p-1 transition-all ${isPlaying ? 'text-green-400' : 'text-gray-500 hover:text-white'}`}
                >
                  {isGeneratingAudio ? <Loader2 className="w-4 h-4 animate-spin" /> : isPlaying ? <StopCircle className="w-4 h-4" /> : <Volume2 className="w-4 h-4" />}
                </button>
                {(builderStep === 4 && pipeline.masterPrompt) && (
                  <button onClick={handleCopy} className={`p-1 transition-all ${copied ? 'text-green-400' : 'text-gray-500 hover:text-white'}`}>
                    {copied ? <Check className="w-4 h-4" /> : <Copy className="w-4 h-4" />}
                  </button>
                )}
                <button
                  onClick={() => setIsTerminalMaximized(false)}
                  className="p-1 text-gray-500 hover:text-white transition-all"
                  title={aiLabLabels.close}
                >
                  <Minimize2 className="w-5 h-5" />
                </button>
              </div>
            </div>

            {/* Modal Content - Full conversation */}
            <div className="flex-1 min-h-0 p-4 md:p-6 font-mono text-sm overflow-y-auto terminal-glow custom-scrollbar">
              {isGenerating || (isChatLoading && mode === 'explorer') ? (
                <div className="flex flex-col items-center justify-center h-full space-y-4">
                  <Loader2 className="w-12 h-12 text-green-400 animate-spin" />
                  <p className="text-sm font-mono uppercase tracking-widest text-gray-500">{t.processing}</p>
                </div>
              ) : (
                <div className="animate-fade-in markdown-content max-w-4xl mx-auto">
                  {mode === 'explorer' && chatMessages.length > 0 ? (
                    <div className="space-y-6">
                      <div className="text-green-400 text-lg">&gt; {activeThread?.title}</div>
                      <div className="text-gray-600 text-xs">[{chatMessages.length} {aiLabLabels.messages}]</div>

                      {chatMessages.map((msg, idx) => (
                        <div key={idx} className={`${msg.role === 'user' ? 'border-l-4 border-yellow-400 pl-6 py-2' : 'py-2'}`}>
                          <span className={`font-mono text-xs uppercase ${msg.role === 'user' ? 'text-yellow-400' : 'text-green-400'}`}>
                            {msg.role === 'user' ? '> USER' : '< AI'}
                          </span>
                          {msg.role === 'user' ? (
                            <p className="text-white text-base mt-2">"{msg.content}"</p>
                          ) : (
                            <div className="text-white mt-3">
                              <ReactMarkdown components={{
                                h1: ({ node, ...props }) => <h1 className="text-2xl font-bold text-yellow-400 mb-4" {...props} />,
                                h2: ({ node, ...props }) => <h2 className="text-lg font-bold text-green-400 mt-6 mb-3" {...props} />,
                                strong: ({ node, ...props }) => <strong className="text-yellow-400 font-bold" {...props} />,
                                ul: ({ node, ...props }) => <ul className="space-y-2 my-4" {...props} />,
                                li: ({ node, ...props }) => <li className="text-gray-300 pl-6 relative before:content-['+'] before:absolute before:left-0 before:text-yellow-400 before:font-bold" {...props} />,
                                code: ({ node, ...props }) => <code className="bg-basalt-800 text-green-300 px-2 py-1 text-sm" {...props} />,
                                pre: ({ node, ...props }) => <pre className="bg-basalt-800/50 p-4 border border-basalt-700 my-4 overflow-x-auto text-sm text-green-300" {...props} />,
                                p: ({ node, ...props }) => <p className="text-base text-gray-300 my-3 leading-relaxed" {...props} />,
                              }}>
                                {msg.content}
                              </ReactMarkdown>
                            </div>
                          )}
                          {idx < chatMessages.length - 1 && <div className="border-b border-basalt-800 my-6" />}
                        </div>
                      ))}
                    </div>
                  ) : mode === 'builder' && builderStep > 0 ? (
                    <div>
                      <div className="text-green-400 mb-4 text-lg">&gt; BUILD_PIPELINE</div>
                      <div className="text-gray-500 mb-6">[SYSTEM] Platform: {pipeline.platform?.toUpperCase()} | Step: {builderStep}/4</div>
                      <ReactMarkdown components={{
                        h1: ({ node, ...props }) => <h1 className="text-3xl font-bold text-yellow-400 mt-8 mb-6 border-b border-basalt-700 pb-3" {...props} />,
                        h2: ({ node, ...props }) => <h2 className="text-xl font-bold text-green-400 mt-8 mb-4" {...props} />,
                        strong: ({ node, ...props }) => <strong className="text-yellow-400 font-bold" {...props} />,
                        code: ({ node, ...props }) => <code className="bg-basalt-800 text-green-300 px-2 py-1 text-sm font-medium" {...props} />,
                        pre: ({ node, ...props }) => <pre className="bg-basalt-800/50 p-6 my-6 overflow-x-auto text-sm text-green-300 border border-basalt-700" {...props} />,
                        ul: ({ node, ...props }) => <ul className="space-y-2 my-4 text-gray-300" {...props} />,
                        li: ({ node, ...props }) => <li className="pl-6 relative before:content-['+'] before:absolute before:left-0 before:text-yellow-400 before:font-bold" {...props} />,
                        p: ({ node, ...props }) => <p className="text-base text-gray-300 my-3 leading-relaxed" {...props} />,
                      }}>
                        {(builderStep === 1 ? pipeline.idea : builderStep === 2 ? pipeline.validation : builderStep === 3 ? pipeline.prd : pipeline.masterPrompt) || ''}
                      </ReactMarkdown>
                    </div>
                  ) : (
                    <div className="flex flex-col items-center justify-center h-full text-gray-600">
                      <Terminal className="w-20 h-20 mb-6 stroke-[1px]" />
                      <p className="text-sm uppercase tracking-widest">{aiLabLabels.noContentYet}</p>
                    </div>
                  )}
                </div>
              )}
            </div>

            {/* Modal Input */}
            {mode === 'explorer' && activeThreadId && (
              <div className="p-4 bg-basalt-900 border-t-2 border-basalt-700 flex items-center gap-4 flex-shrink-0">
                <span className="text-yellow-400 font-mono font-bold text-lg">$</span>
                <input
                  type="text"
                  value={followUpInput}
                  onChange={(e) => setFollowUpInput(e.target.value)}
                  onKeyDown={(e) => e.key === 'Enter' && !e.shiftKey && handleFollowUp()}
                  className="bg-transparent border-none outline-none font-mono text-base flex-grow text-white placeholder:text-gray-500"
                  placeholder={aiLabLabels.continueConversation}
                  disabled={isChatLoading}
                  autoFocus
                />
                <button
                  onClick={handleFollowUp}
                  disabled={isChatLoading || !followUpInput.trim()}
                  className="bg-yellow-400 text-black px-4 py-2 font-bold disabled:opacity-50 transition-colors flex items-center gap-2"
                >
                  {isChatLoading ? <Loader2 className="w-5 h-5 animate-spin" /> : <Send className="w-5 h-5" />}
                </button>
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
};
